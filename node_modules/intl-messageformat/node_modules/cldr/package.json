{
  "name": "cldr",
  "version": "2.0.1",
  "description": "Library for extracting data from CLDR (the Unicode Common Locale Data Repository)",
  "main": "lib/cldr.js",
  "scripts": {
    "test": "mocha --check-leaks",
    "prepublish": "npm test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/papandreou/node-cldr.git"
  },
  "dependencies": {
    "libxmljs": "=0.7.1",
    "passerror": "=0.0.1",
    "pegjs": "=0.7.0",
    "seq": "=0.3.5",
    "uglify-js": "=1.3.3",
    "underscore": "=1.3.3"
  },
  "devDependencies": {
    "mocha": "=1.15.1",
    "unexpected": "=1.0.11"
  },
  "keywords": [
    "locale",
    "i18n",
    "cldr",
    "l10n",
    "internationalization",
    "localization",
    "date",
    "time",
    "interval",
    "format",
    "formats",
    "pattern",
    "patterns",
    "plural",
    "plurals",
    "number",
    "country",
    "territory",
    "time",
    "zone",
    "timezone",
    "currency",
    "script",
    "list",
    "units"
  ],
  "author": {
    "name": "Andreas Lind Petersen",
    "email": "andreas@one.com"
  },
  "license": "BSD",
  "readme": "cldr\n====\n\nA module that allows you to extract a bunch of locale-specific\ninformation from the <a href=\"http://cldr.unicode.org/\">Unicode\nCLDR</a> (Common Localization Data Repository), including:\n\n* Date, time, and date-time formats\n* Date interval formats\n* Number formats, symbols, and digits for all number systems\n* Exemplar and ellipsis characters\n* Day names, month names, quarter names, era names, and cyclic names\n* Patterns for rendering lists of items\n* Display names for languages, time zones, territories, scripts and currencies\n* Plural rule functions (converted to JavaScript functions)\n* Rule-based number formatting functions (converted to JavaScript functions)\n\nThe extraction code was originally written for the <a\nhref=\"https://github.com/papandreou/inter\">inter i18n library</a>, but can be\nused on its own.\n\nTo understand the data itself, you might need to dive into the <a\nhref=\"http://www.unicode.org/reports/tr35/tr35-29.html\">LDML\nspecification</a>, which describes the schema of the CLDR XML files.\n\nComes bundled with the CLDR 24 release and isn't attempting to be backwards\ncompatible with earlier versions.\n\nUsage\n=====\n\nMake sure you have <a href=\"http://nodejs.org/\">node.js</a> and <a\nhref=\"http://npmjs.org/\">npm</a> installed, then run:\n\n```\n$ npm install cldr\n```\n\nNow you're ready to create a node-cldr instance and take it for a\nspin:\n\n```javascript\nvar cldr = require('cldr');\n\nconsole.log(cldr.extractTerritoryDisplayNames('fr'));\n```\n\nOutput:\n\n```\n{ '142': 'Asie',\n  '143': 'Asie centrale',\n  '145': 'Asie occidentale',\n  '150': 'Europe',\n  [...]\n  YT: 'Mayotte',\n  ZA: 'Afrique du Sud',\n  ZM: 'Zambie',\n  ZW: 'Zimbabwe',\n  ZZ: 'région indéterminée' }\n```\n\nAdvanced users can also provide the path to another CLDR installation\nlike this:\n\n```javascript\nvar cldr = require('cldr').load('/path/to/cldr');\n```\n\nProperties\n==========\n\n### cldr.localeIds ###\n\nAn array of locale ids for which data is available (656 in CLDR\nrelease 22.1). The locale ids are \"normalized\" to be all lower case\nwith underscores separating the fragments. However, all methods that\ntake a locale id as a parameter will accept any casing and both `-`\nand `_` as separators.\n\n### cldr.calendarIds ###\n\nAn array of calendar ids for which data is available. In CLDR release\n22.1:\n\n```javascript\n[ 'buddhist', 'chinese', 'coptic', 'dangi', 'ethioaa', 'ethiopic',\n  'gregorian', 'hebrew', 'indian', 'islamic', 'islamicc', 'iso8601',\n  'japanese', 'persian', 'roc' ]\n```\n\n### cldr.numberSystemIds ###\n\nAn array of number system ids for which data is available. In CLDR\nrelease 22.1:\n\n```javascript\n[ 'arab', 'arabext', 'armn', 'armnlow', 'bali', 'beng', 'brah',\n  'cakm', 'cham', 'deva', 'ethi', 'finance', 'fullwide', 'geor',\n  'grek', 'greklow', 'gujr', 'guru', 'hanidec', 'hans', 'hansfin',\n  'hant', 'hantfin', 'hebr', 'java', 'jpan', 'jpanfin', 'kali',\n  'khmr', 'knda', 'lana', 'lanatham', 'laoo', 'latn', 'lepc',\n  'limb', 'mlym', 'mong', 'mtei', 'mymr', 'mymrshan', 'native',\n  'nkoo', 'olck', 'orya', 'osma', 'roman', 'romanlow', 'saur',\n  'shrd', 'sora', 'sund', 'takr', 'talu', 'taml', 'tamldec',\n  'telu', 'thai', 'tibt', 'traditio', 'vaii' ]\n```\n\nMethods\n=======\n\nAll the data extraction methods are synchronous, which means that XML\ndocuments that haven't already been loaded will be loaded using\n`fs.readFileSync`. The reasoning behind this is that the API would be\nawkward if all the extraction methods had to take callbacks. Also,\n`node-cldr` is unlikely to be used in a setting where performance is\ncritical. However, if for some reason you want to avoid the\nsynchronous loads, you can use `cldr.load(<arrayOfLocaleIds>, cb)` to\nload all the needed data in parallel before starting the extraction\nitself. Then all the needed documents will be loaded and ready.\n\n### cldr.extractLanguageDisplayNames(localeId='root') ###\n\nExtract a locale ID => display name hash for a locale:\n\n```javascript\ncldr.extractLanguageDisplayNames('it').en;\n'inglese'\n```\n\n### cldr.extractTimeZoneDisplayNames(localeId='root') ###\n\nExtract a time zone ID (Olson) => display name hash for a locale:\n\n```javascript\ncldr.extractTimeZoneDisplayNames('it')['Europe/Gibraltar'];\n'Gibilterra'\n```\n\n### cldr.extractTimeZoneFormats(localeId='root') ###\n\nExtract a hash with ICU formats for displaying information about a\ntime zone in a locale:\n\n```javascript\ncldr.extractTimeZoneFormats('da');\n{ hour: [ '+HH.mm', '-HH.mm' ],\n  gmt: 'GMT{0}',\n  gmtZero: 'GMT',\n  region: 'Tidszone for {0}',\n  fallback: '{1} ({0})',\n  fallbackRegion: 'Tidszone for {1} ({0})' }\n```\n\n### cldr.extractTerritoryDisplayNames(localeId='root') ###\n\nExtract a territory ID => display name hash for a locale:\n\n```javascript\ncldr.extractTerritoryDisplayNames('fr').US;\n'États-Unis'\n```\n\n### cldr.extractCurrencyInfoById(localeId='root') ###\n\nExtract hash with currency ID keys mapping to currency info objects\nfor a locale:\n\n```javascript\ncldr.extractCurrencyInfoById('es').YUN;\n{ displayName: 'dinar convertible yugoslavo',\n  symbol: undefined,\n  one: 'dinar convertible yugoslavo',\n  other: 'dinares convertibles yugoslavos' },\n```\n\n### cldr.extractScriptDisplayNames(localeId='root') ###\n\nExtract a script ID => display name hash for a locale:\n\n```javascript\ncldr.extractScriptDisplayNames('en_US').Arab;\n'Arabic'\n```\n\n### cldr.extractEraNames(localeId='root', calendarId='gregorian') ###\n\nExtract a nested hash with era names in `wide` and `abbreviated`\nformats for a calendar and locale:\n\n```javascript\ncldr.extractEraNames('es', 'gregorian');\n{ wide:\n   { '0': 'antes de Cristo',\n     '1': 'anno Dómini' },\n  abbreviated:\n   { '0': 'a.C.',\n     '1': 'd.C.' } }\n```\n\n### cldr.extractQuarterNames(localeId='root', calendarId='gregorian') ###\n\nExtract a nested hash with quarter names in various formats for a calendar and locale:\n\n```javascript\ncldr.extractQuarterNames('es', 'gregorian');\n{ format:\n   { abbreviated: { '0': 'T1', '1': 'T2', '2': 'T3', '3': 'T4' },\n     narrow: { '0': '1T', '1': '2T', '2': '3T', '3': '4T' },\n     wide: { '0': '1er trimestre', '1': '2º trimestre', '2': '3er trimestre', '3': '4º trimestre' } },\n  standAlone:\n   { abbreviated: { '0': 'Q1', '1': 'Q2', '2': 'Q3', '3': 'Q4' },\n     narrow: { '0': '1T', '1': '2T', '2': '3T', '3': '4T' },\n     wide: { '0': '1.er trimestre', '1': '2.º trimestre', '2': '3.er trimestre', '3': '4.º trimestre' } } }\n```\n\n### cldr.extractDayPeriods(localeId='root', calendarId='gregorian') ###\n\nExtract a nested hash with day periods in various formats for a\ncalendar and locale:\n\n```javascript\ncldr.extractDayPeriods('en_GB', 'gregorian');\n{ format:\n   { abbreviated: { am: 'AM', pm: 'PM' },\n     narrow: { am: 'a', noon: 'n', pm: 'p' },\n     wide: { am: 'am', pm: 'pm', noon: 'noon' } },\n  standAlone:\n   { abbreviated: { am: 'AM', pm: 'PM' },\n     narrow: { am: 'AM', pm: 'PM' },\n     wide: { am: 'AM', pm: 'PM' } } }\n```\n\n### cldr.extractCyclicNames(localeId='root', calendarId='gregorian') ###\n\nExtract a nested hash with cyclic names for a calendar and locale\n(only the `chinese` calendar contains these):\n\n```javascript\ncldr.extractCyclicNames('en_US', 'chinese').zodiacs.format.abbreviated;\n{ '1': 'Rat', '2': 'Ox', '3': 'Tiger', '4': 'Rabbit', '5': 'Dragon', '6': 'Snake', '7': 'Horse', '8': 'Goat', '9': 'Monkey', '10': 'Rooster', '11': 'Dog', '12': 'Pig' }\n```\n\n### cldr.extractMonthNames(localeId='root', calendarId='gregorian') ###\n\nExtract a nested hash with month names (in various contexts) for a\ncalendar and locale:\n\n```javascript\ncldr.extractMonthNames('nl', 'gregorian').format.wide;\n{ '0': 'januari', '1': 'februari', '2': 'maart', '3': 'april', '4': 'mei', '5': 'juni', '6': 'juli',\n  '7': 'augustus', '8': 'september', '9': 'oktober', '10': 'november', '11': 'december' }\n```\n\n### cldr.extractMonthPatterns(localeId='root', calendarId='gregorian') ###\n\nExtract a nested hash with month patterns (in various contexts) for a\ncalendar and locale:\n\n```javascript\ncldr.extractMonthPatterns('nl', 'chinese');\n{ format:\n   { abbreviated: { leap: '{0}bis' },\n     narrow: { leap: '{0}b' },\n     wide: { leap: '{0}bis' } },\n  numeric: { all: { leap: '{0}bis' } },\n  standAlone:\n   { abbreviated: { leap: '{0}bis' },\n     narrow: { leap: '{0}b' },\n     wide: { leap: '{0}bis' } } }\n```\n\n### cldr.extractDayNames(localeId='root', calendarId='gregorian') ###\n\nExtract a nested hash with day names (in various contexts) for a\ncalendar and locale:\n\n```javascript\ncldr.extractDayNames('en', 'gregorian').format.abbreviated;\n{ '0': 'Sun',\n  '1': 'Mon',\n  '2': 'Tue',\n  '3': 'Wed',\n  '4': 'Thu',\n  '5': 'Fri',\n  '6': 'Sat' }\n```\n\n### cldr.extractFields(localeId='root') ###\n\nExtract a nested hash with display names (including relative) for\nvarious fields for a locale:\n\n```javascript\ncldr.extractFields('en').month;\n{ displayName: 'Month',\n  relative:\n   { '0': 'this month',\n     '1': 'next month',\n     '-1': 'last month' },\n  relativeTime:\n   { future:\n      { one: 'in {0} month',\n        other: 'in {0} months' },\n     past:\n      { one: '{0} month ago',\n        other: '{0} months ago' } } }\n```\n\n### cldr.extractDateTimePatterns(localeId='root', calendarId='gregorian') ###\n\nExtract a hash with ICU patterns that show how to build a date-time\npattern out of a date pattern and a time pattern in various contexts\nfor a calendar and locale:\n\n```javascript\ncldr.extractDateTimePatterns('en', 'gregorian');\n{ full: '{1} \\'at\\' {0}',\n  long: '{1} \\'at\\' {0}',\n  medium: '{1}, {0}',\n  short: '{1}, {0}' }\n```\n\n### cldr.extractDateFormats(localeId='root', calendarId='gregorian') ###\n\nExtract a hash of basic date formats (ICU) for a calendar and locale:\n\n```javascript\ncldr.extractDateFormats('en_GB', 'gregorian');\n{ full: 'EEEE, d MMMM y',\n  long: 'd MMMM y',\n  medium: 'd MMM y',\n  short: 'dd/MM/yyyy' }\n```\n\n### cldr.extractTimeFormats(localeId='root', calendarId='gregorian') ###\n\nExtract a hash of basic time formats (ICU) for a given calendar and\nlocale:\n\n```javascript\ncldr.extractTimeFormats('en_GB', 'gregorian');\n{ full: 'HH:mm:ss zzzz',\n  long: 'HH:mm:ss z',\n  medium: 'HH:mm:ss',\n  short: 'HH:mm' }\n```\n\n### cldr.extractDateFormatItems(localeId='root', calendarId='gregorian') ###\n\nExtract a hash of <a\nhref=\"http://www.unicode.org/reports/tr35/tr35-29.html#Date_Format_Patterns\">ICU\ndate formats</a> for displaying dates and times at various detail\nlevels for a calendar and locale:\n\n```javascript\ncldr.extractDateFormatItems('en_GB', 'gregorian');\n{ d: 'd',\n  Ed: 'E d',\n  Ehm: 'E h:mm a',\n  EHm: 'E HH:mm',\n  [...]\n  yQQQ: 'QQQ y',\n  yyMMM: 'MMM yy',\n  yyyyMM: 'MM/yyyy',\n  yyyyMMMM: 'MMMM y' }\n```\n\n### cldr.extractDateIntervalFormats(localeId='root', calendarId='gregorian') ###\n\nExtract a nested hash with date interval display formats (ICU), keyed\nby the detail level and the 'greatest difference' field for a calendar\nand a locale (tip: Look for \"greatest difference\" in the <a\nhref=\"http://www.unicode.org/reports/tr35/tr35-29.html\">LDML\nspec</a>):\n\n```javascript\ncldr.extractDateIntervalFormats('en_GB', 'gregorian');\n{ d: { d: 'd–d' },\n  h: { a: 'h a – h a', h: 'h–h a' },\n  H: { H: 'HH–HH' },\n  hm: { a: 'h:mm a – h:mm a', h: 'h:mm–h:mm a', m: 'h:mm–h:mm a' },\n  [...]\n  yMMMEd:\n   { d: 'E, d – E, d MMM y',\n     M: 'E, d MMM – E, d MMM y',\n     y: 'E, d MMM y – E, d MMM y' },\n  yMMMM: { M: 'MMMM–MMMM y', y: 'MMMM y – MMMM y' } }\n```\n\n### cldr.extractDateIntervalFallbackFormat(localeId='root', calendarId='gregorian') ###\n\nExtract the date interval fallback format (ICU) for a given calendar\nand locale (to be used when the date interval formats don't offer a\nspecific format):\n\n```javascript\ncldr.extractDateIntervalFallbackFormat('en_GB', 'gregorian');\n'{0} – {1}'\n```\n\n### cldr.extractNumberSymbols(localeId='root', numberSystemId='latn') ###\n\nExtract the number symbols for a given number system and locale:\n\n```javascript\ncldr.extractNumberSymbols('en_GB', 'latn');\n{ decimal: '.',\n  group: ',',\n  list: ';',\n  percentSign: '%',\n  plusSign: '+',\n  minusSign: '-',\n  exponential: 'E',\n  perMille: '‰',\n  infinity: '∞',\n  nan: 'NaN' }\n```\n\n### cldr.extractNumberFormats(localeId='root', numberSystemId='latn') ###\n\nExtract the number formats (<a\nhref=\"http://www.unicode.org/reports/tr35/tr35-29.html#Number_Format_Patterns\">ICU\nDecimalFormat</a>) for a given number system and locale:\n\n```javascript\ncldr.extractNumberFormats('en_GB', 'latn');\n{ scientific: { default: '#E0' },\n  decimal:\n   { long:\n      { '1000': { one: '0 thousand', other: '0 thousand' },\n        '10000': { one: '00 thousand', other: '00 thousand' },\n        [...]\n        '100000000000000': { one: '000 trillion', other: '000 trillion' } },\n     short:\n      { '1000': { one: '0k', other: '0K' },\n        '10000': { one: '00k', other: '00K' },\n        [...]\n        '100000000000000': { one: '000tn', other: '000T' } },\n     default: '#,##0.###' },\n  currency: { default: '¤#,##0.00', one: '{0} {1}', other: '{0} {1}' },\n  percent: { default: '#,##0%' } }\n```\n\n### cldr.extractDefaultNumberSystemId(localeId='root') ###\n\nExtract the id of the default number system for a locale:\n\n```javascript\ncldr.extractDefaultNumberSystemId('en_GB');\n'latn'\ncldr.extractDefaultNumberSystemId('ar');\n'arab'\n```\n\n### cldr.extractUnitPatterns(localeId='root') ###\n\nExtract the unit patterns (ICU) for a locale (to be used with a plural rule function):\n\n```javascript\ncldr.extractUnitPatterns('en_GB').long.unit.massKilogram\n{ one: '{0} kilogram',\n  other: '{0} kilograms' }\n```\n\n### cldr.extractDelimiters(localeId='root') ###\n\nExtract the delimiters for a locale:\n\n```javascript\ncldr.extractDelimiters('en_GB');\n{ quotationStart: '“',\n  quotationEnd: '”',\n  alternateQuotationStart: '‘',\n  alternateQuotationEnd: '’' }\n```\n\n### cldr.extractListPatterns(localeId='root') ###\n\nExtract the list patterns (ICU) for a locale:\n\n```javascript\nObject.keys(cldr.extractListPatterns('en_GB'));\n[ 'default',\n  'unit',\n  'unitNarrow',\n  'unitShort' ]\ncldr.extractListPatterns('en_GB').default;\n{ '2': '{0} and {1}',\n  end: '{0} and {1}',\n  middle: '{0}, {1}',\n  start: '{0}, {1}' }\n```\n\n### cldr.extractCharacters(localeId='root') ###\n\nExtract information about various character classes, ellipsis patterns etc. for a locale:\n\n```javascript\ncldr.extractCharacters('en_GB');\n{ exemplar:\n   { default: [ 'a', 'b', 'c', 'd', 'e', [...], 'x', 'y', 'z' ],\n     auxiliary: [ 'á', 'à', 'ă', 'â', 'å', [...], 'ü', 'ū', 'ÿ' ],\n     index: [ 'A', 'B', 'C', 'D', 'E', [...], 'X', 'Y', 'Z' ],\n     punctuation: [ '\\\\-', '‐', '–', '—', ',', [...], '‡', '′', '″' ] },\n  ellipsis: { final: '{0}…', initial: '…{0}', medial: '{0}… {1}' },\n  moreInformation: '?' }\n```\n\n### cldr.extractPluralRuleFunction(localeId='root') ###\n\nExtract a plural rule function for a locale (See <a\nhref=\"http://www.unicode.org/reports/tr35/tr35-29.html#Language_Plural_Rules\">the\nLDML spec</a> for an explanation):\n\n```javascript\ncldr.extractPluralRuleFunction('en_GB').toString();\nfunction (n) {\n    if (n === 1) return \"one\";\n    return \"other\";\n}\ncldr.extractPluralRuleFunction('ar').toString();\nfunction (n) {\n    if (n === 0) return \"zero\";\n    if (n === 1) return \"one\";\n    if (n === 2) return \"two\";\n    if (n % 100 >= 3 && n % 100 <= 10) return \"few\";\n    if (n % 100 >= 11 && n % 100 <= 99) return \"many\";\n    return \"other\";\n}\n```\n\n### cldr.extractRbnfFunctionByType(localeId='root'[, types]) ###\n\nExtracts RBNF (<a\nhref=\"http://www.unicode.org/reports/tr35/tr35-29.html#Rule-Based_Number_Formatting\">rule-based\nnumber formatting</a>) functions for a locale. The 'types' parameter\nspecifies the names of the functions you want (defaults to all\navailable), and the returned hash will contain the ones that were\nfound plus their dependencies.\n\nThe original function names have been converted to camelCase and\nprefixed with `render`, and you need to use that naming convention\nwhen specifying the `types` array as well.\n\n```javascript\ncldr.extractRbnfFunctionByType('en_GB').renderRomanUpper(2012);\n'MMXII'\ncldr.extractRbnfFunctionByType('de').renderSpelloutOrdinal(2323);\n'zwei tausend drei hundert drei und zwanzigste'\n```\n\nNote that some of the generated functions expect to be able to call\n`this.renderNumber(<number>, <icuNumberFormat>);`. If there's demand\nfor it, that can be made customizable, just file an issue.\n\n\n### cldr.extractDigitsByNumberSystemId() ###\n\nExtract a hash of number system id => digits array. For some exotic\nnumber systems, 'digits' is a string starting with `render`. In that\ncase, use the RBNF function (see above) of that name for producing a\nnumber.\n\n```javascript\ncldr.extractDigitsByNumberSystemId();\n{ arab: [ '٠', '١', '٢', '٣', '٤', '٥', '٦', '٧', '٨', '٩' ],\n  arabext: [ '۰', '۱', '۲', '۳', '۴', '۵', '۶', '۷', '۸', '۹' ],\n  armn: 'renderArmenianUpper',\n  armnlow: 'renderArmenianLower',\n  [...]\n  latn: [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' ],\n  orya: [ '୦', '୧', '୨', '୩', '୪', '୫', '୬', '୭',  '୮',  '୯' ],\n  [...] }\n```\n\nLicense\n-------\n\nnode-cldr is licensed under a standard 3-clause BSD license -- see the\n`LICENSE`-file for details.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/papandreou/node-cldr/issues"
  },
  "_id": "cldr@2.0.1",
  "_from": "cldr@~2.0.1"
}
